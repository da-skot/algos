/*
Внимание. Используется код (64, 57).
Код Хэмминга добавляет к сообщению (информационные разряды) некоторое количество избыточной информации (проверочные разряды), сформированной определённым образом. 
Сообщение с добавленной проверочной информацией называется «кодовый символ» или «кодовое слово». Параметры кода указываются, например, так: (7, 4). 
Это означает, что длина кодового слова равна 7 битам, а длина сообщения – 4 бита. 
В зависимости от количества информационных и проверочных разрядов в кодовых словах существуют коды Хэмминга (7,4), (9,5), (11, 7), (15, 11), (31, 26), (63, 57) и т. д.

Чтобы восстановить закодированное сообщение, оно подвергается декодированию. При этом есть вероятность, что исходное сообщение нельзя будет восстановить, 
в случае превышения числом ошибок корректирующей способности кода. Однако помехоустойчивость закодированной информации всё равно выше, чем у незакодированной.

Из-за своей простоты, кодирование кодом Хемминга получило широкое распространение. Оно применяется, например, в беспроводной технологии WiFi, в системах хранения данных (RAID-массивах), в некоторых типах микросхем памяти, в схемотехнике и т.д.

Формат ввода
Двоичное сообщение, которое необходимо закодировать с использованием кода Хэмминга.

Формат вывода
Закодированное сообщение с использованием кода Хэмминга. Внимание. Используется код (64, 57).
*/

using System;
using System.Collections.Generic;

namespace Decode_Hamming
{
    class Program
    {
        static void Main(string[] args)
        {
            string str = Console.ReadLine();
            List<int> arr = new List<int>();
            for (int i = 0; i < str.Length; i++)
                arr.Add(Int32.Parse(str[i].ToString()));
            int m = 57, k = 63 - 57;
            encode(arr, m, k);
        }
        static void encode(List<int> arr, int m, int k)
        {
            int parity = 0;
            int[] encode = new int[m + k];
            for (int i = 0; i < k; i++)
                encode[(int)Math.Pow(2, i) - 1] = -1;
            int j = 0;
            for (int i = 0; i < encode.Length; i++)
                if(encode[i] != -1 && j < arr.Count)
                {
                    encode[i] = arr[j];
                    j++;
                    if (encode[i] == 1)
                        parity++;
                }            
            for (int i = 0; i < encode.Length; i++)
            {
                if (encode[i] != -1)
                    continue;

                int x = (int)Math.Log(i + 1, 2);
                int one_count = 0;

                for (j = i + 2; j <= encode.Length; ++j)
                    if ((j & (1 << x)) > 0)
                        if (encode[j - 1] == 1)
                            one_count++;
                 encode[i] = one_count % 2;
                if (encode[i] == 1)
                    parity++;
            }
            Console.WriteLine($"{parity % 2}"+String.Join("", encode));
        }
    }
}
