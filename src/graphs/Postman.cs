/*
В городе есть N площадей, соединенных улицами. При этом количество улиц не превышает 100000 и существует не более трех площадей, на которые выходит нечетное количество улиц.
Для каждой улицы известна ее длина. По каждой улице разрешено движение в обе стороны. В городе есть хотя бы одна улица. От каждой площади до любой другой можно дойти по улицам.

Почтальону требуется пройти хотя бы один раз по каждой улице. Почтальон хочет, чтобы длина его пути была минимальна. 
Он может начать движение на любой площади и закончить также на любой (в том числе и на начальной).

Помогите почтальону составить такой маршрут.

Формат ввода
Сначала записано число N — количество площадей в городе (2≤N≤1000). Далее следуют N строк, задающих улицы. 
В i-ой из этих строк находится число mi — количество улиц, выходящих из площади i. Далее следуют m_i пар натуральных чисел: 
в j-ой паре первое число — номер площади, в которую идет j-ая улица с i-ой площади, а второе число — длина этой улицы.

Между двумя площадями может быть несколько улиц, но не может быть улицы с площади на нее саму.

Все числа во входном файле не превосходят 100000

Формат вывода
Если решение существует, то в первую строку выходного файла выведите одно число — количество улиц в искомом маршруте, а во вторую — номера площадей в порядке их посещения.

Если решения нет, выведите в выходной файл одно число –1.

Если решений несколько, выведите любое.
*/
using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;


namespace Postman_A
{
    class Program
    {
        static private int[,] g;
        static private List<int> EulerPath = new List<int>();
        static void Main(string[] args)
        {
            int n = Int32.Parse(Console.ReadLine());
            g = new int[n, n];
            int index, start = 0;
            for (int i = 0; i < n; i++)
            {
                string[] str = Regex.Replace(Console.ReadLine().Trim(), "[ ]+", " ").Split(' ');
                int m = Int32.Parse(str[0]);
                if (m % 2 == 1)
                    start = i;
                index = 1;
                for (int j = 0; j < m; j++)
                {
                    g[i, Int32.Parse(str[index]) - 1]++;
                    index += 2;
                }
            }
            FindEulerPath(start);
            Console.WriteLine(EulerPath.Count-1);
            foreach (int v in EulerPath)
                Console.Write($"{v+1} ");
        }
        private static void FindEulerPath(int v)
        {
            for(int i = 0; i<g.GetLength(0);i++)
                if(g[v,i] > 0)
                {
                    g[v, i]--;
                    g[i, v]--;
                    FindEulerPath(i);
                }
            EulerPath.Add(v);
        }
    }
}
